// auto-generated: Bhojpur GUI - Foundation Framework
// Code generated by '$ guiutl bundle'. DO NOT EDIT.

package templates

import gui "github.com/bhojpur/gui/pkg/engine"

var resourceInfoPlist = &gui.StaticResource{
	StaticName: "Info.plist",
	StaticContent: []byte(
		"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple Computer//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>CFBundleName</key>\n\t<string>{{.Name}}</string>\n\t<key>CFBundleExecutable</key>\n\t<string>{{.ExeName}}</string>\n\t<key>CFBundleIdentifier</key>\n\t<string>{{.AppID}}</string>\n\t<key>CFBundleIconFile</key>\n\t<string>icon.icns</string>\n\t<key>CFBundleShortVersionString</key>\n\t<string>{{.Version}}</string>\n\t<key>CFBundleSupportedPlatforms</key>\n\t<array>\n\t\t<string>MacOSX</string>\n\t</array>\n\t<key>CFBundleVersion</key>\n\t<string>{{.Build}}</string>\n\t<key>NSHighResolutionCapable</key>\n\t<true/>\n\t<key>NSSupportsAutomaticGraphicsSwitching</key>\n\t<true/>\n\t<key>CFBundleInfoDictionaryVersion</key>\n\t<string>6.0</string>\n\t<key>CFBundlePackageType</key>\n\t<string>APPL</string>\n\t<key>LSApplicationCategoryType</key>\n\t<string>public.app-category.{{.Category}}</string>\n\t<key>LSMinimumSystemVersion</key>\n\t<string>10.11</string>\n</dict>\n</plist>"),
}
var resourceMakefile = &gui.StaticResource{
	StaticName: "Makefile",
	StaticContent: []byte(
		"# If PREFIX isn't provided, we check for $(DESTDIR)/usr/local and use that if it exists.\n# Otherwice we fall back to using /usr.\n\nLOCAL != test -d $(DESTDIR)/usr/local && echo -n \"/local\" || echo -n \"\"\nLOCAL ?= $(shell test -d $(DESTDIR)/usr/local && echo \"/local\" || echo \"\")\nPREFIX ?= /usr$(LOCAL)\n\ndefault:\n\t# Run \"sudo make install\" to install the Bhojpur GUI application.\n\t# Run \"sudo make uninstall\" to uninstall the Bhojpur GUI application.\n\ninstall:\n\tinstall -Dm00644 usr/{{.Local}}share/applications/{{.Name}}.desktop $(DESTDIR)$(PREFIX)/share/applications/{{.Name}}.desktop\n\tinstall -Dm00755 usr/{{.Local}}bin/{{.Exec}} $(DESTDIR)$(PREFIX)/bin/{{.Exec}}\n\tinstall -Dm00644 usr/{{.Local}}share/pixmaps/{{.Icon}} $(DESTDIR)$(PREFIX)/share/pixmaps/{{.Icon}}\nuninstall:\n\t-rm $(DESTDIR)$(PREFIX)/share/applications/{{.Name}}.desktop\n\t-rm $(DESTDIR)$(PREFIX)/bin/{{.Exec}}\n\t-rm $(DESTDIR)$(PREFIX)/share/pixmaps/{{.Icon}}"),
}
var resourceAppDesktop = &gui.StaticResource{
	StaticName: "app.desktop",
	StaticContent: []byte(
		"[Desktop Entry]\nType=Application\nName={{.Name}}\nExec={{.Exec}}\nIcon={{.Name}}\n"),
}
var resourceAppManifest = &gui.StaticResource{
	StaticName: "app.manifest",
	StaticContent: []byte(
		"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\" xmlns:asmv3=\"urn:schemas-microsoft-com:asm.v3\">\n<assemblyIdentity version=\"{{.CombinedVersion}}\" processorArchitecture=\"*\" name=\"{{.Name}}\" type=\"win32\"/>\n</assembly>"),
}
var resourceAppxmanifestXML = &gui.StaticResource{
	StaticName: "appxmanifest.XML",
	StaticContent: []byte(
		"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Package xmlns=\"http://schemas.microsoft.com/appx/2010/manifest\">\n  <Identity Name=\"{{.AppID}}\"\n            Version=\"{{.Version}}\"\n            Publisher=\"{{.Developer}}\" />\n  <Properties>\n    <DisplayName>{{.Name}}</DisplayName>\n    <PublisherDisplayName>{{.DeveloperName}}</PublisherDisplayName>\n    <Logo>Icon.png</Logo>\n  </Properties>\n  <Prerequisites>\n    <OSMinVersion>6.2</OSMinVersion>\n    <OSMaxVersionTested>10.0</OSMaxVersionTested>\n  </Prerequisites>\n  <Resources>\n    <Resource Language=\"en-us\" />\n  </Resources>\n\n  <!-- TODO <Applications> -->\n</Package>"),
}
var resourceEntitlementsDarwinPlist = &gui.StaticResource{
	StaticName: "entitlements-darwin.plist",
	StaticContent: []byte(
		"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>com.apple.security.app-sandbox</key>\n    <true/>\n</dict>\n</plist>"),
}
var resourceEntitlementsIosPlist = &gui.StaticResource{
	StaticName: "entitlements-ios.plist",
	StaticContent: []byte(
		"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>application-identifier</key>\n    <string>{{.TeamID}}.{{.AppID}}</string>\n</dict>\n</plist>"),
}
var resourceIndexHtml = &gui.StaticResource{
	StaticName: "index.html",
	StaticContent: []byte(
		"<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"utf-8\">\n\t\t<title>Bhojpur GUI - Web Application</title>\n\t\t<meta name=\"author\" content=\"Shashi Bhushan Rai\" />\n\t\t<meta name=\"description\" content=\"A web-scale distributed application using WebAssembly\" />\n\t\t<meta name=\"theme-color\" content=\"#000000\" />\n\t\t<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\" />\n\t\t<link rel=\"shortcut icon\" type=\"image/jpg\" href=\"https://static.bhojpur.net/favicon.ico\"/>\n\t\t<style>\n\t\t\tbody {\n\t\t\t\theight: 100%;\n\t\t\t\twidth: 100%;\n\t\t\t\tpadding: 0;\n\t\t\t\tmargin: 0;\n\t\t\t\tbackground-color: #FFFFFF;\n\t\t\t\tcolor: #000000;\n\t\t\t\tfont-family: Arial, Helvetica, sans-serif\n\t\t\t}\n\t\t</style>\n\t\t{{if not .IsReleased}}\n\t\t\t<script type=\"text/javascript\" src=\"webgl-debug.js\"></script>\n\t\t{{end}}\n\t\t{{if .HasWasm}}\n\t\t\t<script>\n\t\t\t\tvar wasmBuild = true;\n\t\t\t\t//if (window.chrome) {\n\t\t\t\t//\twasmBuild = false;\n\t\t\t\t//}\n\t\t\t</script>\n\t\t{{else}}\n\t\t\t<script>var wasmBuild = false;</script>\n\t\t{{end}}\n\t\t{{if .HasGopherJS}}\n\t\t\t<script>var gopherJSBuild = true;</script>\n\t\t{{else}}\n\t\t\t<script>var gopherJSBuild = false;</script>\n\t\t{{end}}\n\t\t<script>\n\t\t\tfunction async_load(file, cb) {\n\t\t\t\tvar d = document, t = 'script',\n      \t\t\to = d.createElement(t),\n      \t\t\ts = d.getElementsByTagName(t)[0];\n  \t\t\t\to.src = file;\n  \t\t\t\to.addEventListener('load', function (e) { cb(e); }, false);\n  \t\t\t\ts.parentNode.insertBefore(o, s);\n\t\t\t}\n\n\t\t\tfunction webgl_support () {\n\t\t\t\t\ttry {\n\t\t\t\t\tvar canvas = document.createElement('canvas');\n\t\t\t\t\treturn !!window.WebGLRenderingContext &&\n\t\t\t\t\t\t(canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));\n\t\t\t\t} catch(e) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction download_application() {\n\t\t\t\tvar main = document.getElementById(\"main\");\n\n\t\t\t\tif (webgl_support()) {\n\t\t\t\t\tif (wasmBuild && WebAssembly) {\n\t\t\t\t\t\tmain.innerHTML = \"Downloading wasm_exec.js\"\n\t\t\t\t\t\tasync_load(\"wasm_exec.js\", function(){\n\t\t\t\t\t\t\t// WebAssembly.instantiateStreaming is not currently available in Safari\n\t\t\t\t\t\t\tif (WebAssembly && !WebAssembly.instantiateStreaming) { // polyfill\n\t\t\t\t\t\t\t\tWebAssembly.instantiateStreaming = async (resp, importObject) => {\n\t\t\t\t\t\t\t\t\tconst source = await (await resp).arrayBuffer();\n\t\t\t\t\t\t\t\t\treturn await WebAssembly.instantiate(source, importObject);\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmain.innerHTML = \"Downloading web assembly file.\";\n\n\t\t\t\t\t\t\tconst go = new Go();\n\t\t\t\t\t\t\tWebAssembly.instantiateStreaming(fetch(\"{{.WasmFile}}\"), go.importObject).then((result) => {\n\t\t\t\t\t\t\t\tmain.innerHTML = \"\";\n\t\t\t\t\t\t\t\tgo.run(result.instance);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t})\n\t\t\t\t\t} else if (gopherJSBuild) {\n\t\t\t\t\t\tmain.innerHTML = \"Downloading GopherJS file.\";\n\n\t\t\t\t\t\tasync_load(\"{{.GopherJSFile}}\", function(){\n\t\t\t\t\t\t\tmain.innerHTML = \"\";\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmain.innerHTML = \"WebAssembly is not supported in your browser\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmain.innerHTML = \"WebGL is not supported in your browser\";\n\t\t\t\t}\n\t\t\t}\n\t\t</script>\n\t</head>\n\t<body onload=\"download_application()\">\n\t\t<div id=\"main\"></div>\n\t\t<noscript>Javascript need to be enable for this application to work.</noscript>\n\t</body>\n</html>"),
}
var resourceWasmexecJs = &gui.StaticResource{
	StaticName: "wasm_exec.js",
	StaticContent: []byte(
		"// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n//\n// This Javascript file has been modified for use by Bhojpur.NET platform compilation tools.\n\n(() => {\n\t// Map multiple JavaScript environments to a single common API,\n\t// preferring web standards over Node.js API.\n\t//\n\t// Environments considered:\n\t// - Browsers\n\t// - Node.js\n\t// - Electron\n\t// - Parcel\n\n\tif (typeof global !== \"undefined\") {\n\t\t// global already exists\n\t} else if (typeof window !== \"undefined\") {\n\t\twindow.global = window;\n\t} else if (typeof self !== \"undefined\") {\n\t\tself.global = self;\n\t} else {\n\t\tthrow new Error(\"cannot export Go (neither global, window nor self is defined)\");\n\t}\n\n\tif (!global.require && typeof require !== \"undefined\") {\n\t\tglobal.require = require;\n\t}\n\n\tif (!global.fs && global.require) {\n\t\tglobal.fs = require(\"fs\");\n\t}\n\n\tconst enosys = () => {\n\t\tconst err = new Error(\"not implemented\");\n\t\terr.code = \"ENOSYS\";\n\t\treturn err;\n\t};\n\n\tif (!global.fs) {\n\t\tlet outputBuf = \"\";\n\t\tglobal.fs = {\n\t\t\tconstants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 }, // unused\n\t\t\twriteSync(fd, buf) {\n\t\t\t\toutputBuf += decoder.decode(buf);\n\t\t\t\tconst nl = outputBuf.lastIndexOf(\"\\n\");\n\t\t\t\tif (nl != -1) {\n\t\t\t\t\tconsole.log(outputBuf.substr(0, nl));\n\t\t\t\t\toutputBuf = outputBuf.substr(nl + 1);\n\t\t\t\t}\n\t\t\t\treturn buf.length;\n\t\t\t},\n\t\t\twrite(fd, buf, offset, length, position, callback) {\n\t\t\t\tif (offset !== 0 || length !== buf.length || position !== null) {\n\t\t\t\t\tcallback(enosys());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst n = this.writeSync(fd, buf);\n\t\t\t\tcallback(null, n);\n\t\t\t},\n\t\t\tchmod(path, mode, callback) { callback(enosys()); },\n\t\t\tchown(path, uid, gid, callback) { callback(enosys()); },\n\t\t\tclose(fd, callback) { callback(enosys()); },\n\t\t\tfchmod(fd, mode, callback) { callback(enosys()); },\n\t\t\tfchown(fd, uid, gid, callback) { callback(enosys()); },\n\t\t\tfstat(fd, callback) { callback(enosys()); },\n\t\t\tfsync(fd, callback) { callback(null); },\n\t\t\tftruncate(fd, length, callback) { callback(enosys()); },\n\t\t\tlchown(path, uid, gid, callback) { callback(enosys()); },\n\t\t\tlink(path, link, callback) { callback(enosys()); },\n\t\t\tlstat(path, callback) { callback(enosys()); },\n\t\t\tmkdir(path, perm, callback) { callback(enosys()); },\n\t\t\topen(path, flags, mode, callback) { callback(enosys()); },\n\t\t\tread(fd, buffer, offset, length, position, callback) { callback(enosys()); },\n\t\t\treaddir(path, callback) { callback(enosys()); },\n\t\t\treadlink(path, callback) { callback(enosys()); },\n\t\t\trename(from, to, callback) { callback(enosys()); },\n\t\t\trmdir(path, callback) { callback(enosys()); },\n\t\t\tstat(path, callback) { callback(enosys()); },\n\t\t\tsymlink(path, link, callback) { callback(enosys()); },\n\t\t\ttruncate(path, length, callback) { callback(enosys()); },\n\t\t\tunlink(path, callback) { callback(enosys()); },\n\t\t\tutimes(path, atime, mtime, callback) { callback(enosys()); },\n\t\t};\n\t}\n\n\tif (!global.process) {\n\t\tglobal.process = {\n\t\t\tgetuid() { return -1; },\n\t\t\tgetgid() { return -1; },\n\t\t\tgeteuid() { return -1; },\n\t\t\tgetegid() { return -1; },\n\t\t\tgetgroups() { throw enosys(); },\n\t\t\tpid: -1,\n\t\t\tppid: -1,\n\t\t\tumask() { throw enosys(); },\n\t\t\tcwd() { throw enosys(); },\n\t\t\tchdir() { throw enosys(); },\n\t\t}\n\t}\n\n\tif (!global.crypto) {\n\t\tconst nodeCrypto = require(\"crypto\");\n\t\tglobal.crypto = {\n\t\t\tgetRandomValues(b) {\n\t\t\t\tnodeCrypto.randomFillSync(b);\n\t\t\t},\n\t\t};\n\t}\n\n\tif (!global.performance) {\n\t\tglobal.performance = {\n\t\t\tnow() {\n\t\t\t\tconst [sec, nsec] = process.hrtime();\n\t\t\t\treturn sec * 1000 + nsec / 1000000;\n\t\t\t},\n\t\t};\n\t}\n\n\tif (!global.TextEncoder) {\n\t\tglobal.TextEncoder = require(\"util\").TextEncoder;\n\t}\n\n\tif (!global.TextDecoder) {\n\t\tglobal.TextDecoder = require(\"util\").TextDecoder;\n\t}\n\n\t// End of polyfills for common API.\n\n\tconst encoder = new TextEncoder(\"utf-8\");\n\tconst decoder = new TextDecoder(\"utf-8\");\n\tvar logLine = [];\n\n\tglobal.Go = class {\n\t\tconstructor() {\n\t\t\tthis._callbackTimeouts = new Map();\n\t\t\tthis._nextCallbackTimeoutID = 1;\n\n\t\t\tconst mem = () => {\n\t\t\t\t// The buffer may change when requesting more memory.\n\t\t\t\treturn new DataView(this._inst.exports.memory.buffer);\n\t\t\t}\n\n\t\t\tconst setInt64 = (addr, v) => {\n\t\t\t\tmem().setUint32(addr + 0, v, true);\n\t\t\t\tmem().setUint32(addr + 4, Math.floor(v / 4294967296), true);\n\t\t\t}\n\n\t\t\tconst getInt64 = (addr) => {\n\t\t\t\tconst low = mem().getUint32(addr + 0, true);\n\t\t\t\tconst high = mem().getInt32(addr + 4, true);\n\t\t\t\treturn low + high * 4294967296;\n\t\t\t}\n\n\t\t\tconst loadValue = (addr) => {\n\t\t\t\tconst f = mem().getFloat64(addr, true);\n\t\t\t\tif (f === 0) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tif (!isNaN(f)) {\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\n\t\t\t\tconst id = mem().getUint32(addr, true);\n\t\t\t\treturn this._values[id];\n\t\t\t}\n\n\t\t\tconst storeValue = (addr, v) => {\n\t\t\t\tconst nanHead = 0x7FF80000;\n\n\t\t\t\tif (typeof v === \"number\") {\n\t\t\t\t\tif (isNaN(v)) {\n\t\t\t\t\t\tmem().setUint32(addr + 4, nanHead, true);\n\t\t\t\t\t\tmem().setUint32(addr, 0, true);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (v === 0) {\n\t\t\t\t\t\tmem().setUint32(addr + 4, nanHead, true);\n\t\t\t\t\t\tmem().setUint32(addr, 1, true);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tmem().setFloat64(addr, v, true);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tswitch (v) {\n\t\t\t\t\tcase undefined:\n\t\t\t\t\t\tmem().setFloat64(addr, 0, true);\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase null:\n\t\t\t\t\t\tmem().setUint32(addr + 4, nanHead, true);\n\t\t\t\t\t\tmem().setUint32(addr, 2, true);\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase true:\n\t\t\t\t\t\tmem().setUint32(addr + 4, nanHead, true);\n\t\t\t\t\t\tmem().setUint32(addr, 3, true);\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase false:\n\t\t\t\t\t\tmem().setUint32(addr + 4, nanHead, true);\n\t\t\t\t\t\tmem().setUint32(addr, 4, true);\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet id = this._ids.get(v);\n\t\t\t\tif (id === undefined) {\n\t\t\t\t\tid = this._idPool.pop();\n\t\t\t\t\tif (id === undefined) {\n\t\t\t\t\t\tid = this._values.length;\n\t\t\t\t\t}\n\t\t\t\t\tthis._values[id] = v;\n\t\t\t\t\tthis._goRefCounts[id] = 0;\n\t\t\t\t\tthis._ids.set(v, id);\n\t\t\t\t}\n\t\t\t\tthis._goRefCounts[id]++;\n\t\t\t\tlet typeFlag = 1;\n\t\t\t\tswitch (typeof v) {\n\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\ttypeFlag = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"symbol\":\n\t\t\t\t\t\ttypeFlag = 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"function\":\n\t\t\t\t\t\ttypeFlag = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmem().setUint32(addr + 4, nanHead | typeFlag, true);\n\t\t\t\tmem().setUint32(addr, id, true);\n\t\t\t}\n\n\t\t\tconst loadSlice = (array, len, cap) => {\n\t\t\t\treturn new Uint8Array(this._inst.exports.memory.buffer, array, len);\n\t\t\t}\n\n\t\t\tconst loadSliceOfValues = (array, len, cap) => {\n\t\t\t\tconst a = new Array(len);\n\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\ta[i] = loadValue(array + i * 8);\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t}\n\n\t\t\tconst loadString = (ptr, len) => {\n\t\t\t\treturn decoder.decode(new DataView(this._inst.exports.memory.buffer, ptr, len));\n\t\t\t}\n\n\t\t\tconst timeOrigin = Date.now() - performance.now();\n\t\t\tthis.importObject = {\n\t\t\t\twasi_snapshot_preview1: {\n\t\t\t\t\t// https://github.com/WebAssembly/WASI/blob/main/phases/snapshot/docs.md#fd_write\n\t\t\t\t\tfd_write: function(fd, iovs_ptr, iovs_len, nwritten_ptr) {\n\t\t\t\t\t\tlet nwritten = 0;\n\t\t\t\t\t\tif (fd == 1) {\n\t\t\t\t\t\t\tfor (let iovs_i=0; iovs_i<iovs_len;iovs_i++) {\n\t\t\t\t\t\t\t\tlet iov_ptr = iovs_ptr+iovs_i*8; // assuming wasm32\n\t\t\t\t\t\t\t\tlet ptr = mem().getUint32(iov_ptr + 0, true);\n\t\t\t\t\t\t\t\tlet len = mem().getUint32(iov_ptr + 4, true);\n\t\t\t\t\t\t\t\tnwritten += len;\n\t\t\t\t\t\t\t\tfor (let i=0; i<len; i++) {\n\t\t\t\t\t\t\t\t\tlet c = mem().getUint8(ptr+i);\n\t\t\t\t\t\t\t\t\tif (c == 13) { // CR\n\t\t\t\t\t\t\t\t\t\t// ignore\n\t\t\t\t\t\t\t\t\t} else if (c == 10) { // LF\n\t\t\t\t\t\t\t\t\t\t// write line\n\t\t\t\t\t\t\t\t\t\tlet line = decoder.decode(new Uint8Array(logLine));\n\t\t\t\t\t\t\t\t\t\tlogLine = [];\n\t\t\t\t\t\t\t\t\t\tconsole.log(line);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tlogLine.push(c);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.error('invalid file descriptor:', fd);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmem().setUint32(nwritten_ptr, nwritten, true);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t},\n\t\t\t\t\tfd_close: () => 0,      // dummy\n\t\t\t\t\tfd_fdstat_get: () => 0, // dummy\n\t\t\t\t\tfd_seek: () => 0,       // dummy\n\t\t\t\t\t\"proc_exit\": (code) => {\n\t\t\t\t\t\tif (global.process) {\n\t\t\t\t\t\t\t// Node.js\n\t\t\t\t\t\t\tprocess.exit(code);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Can't exit in a browser.\n\t\t\t\t\t\t\tthrow 'trying to exit with code ' + code;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\trandom_get: (bufPtr, bufLen) => {\n\t\t\t\t\t\tcrypto.getRandomValues(loadSlice(bufPtr, bufLen));\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tenv: {\n\t\t\t\t\t// func ticks() float64\n\t\t\t\t\t\"runtime.ticks\": () => {\n\t\t\t\t\t\treturn timeOrigin + performance.now();\n\t\t\t\t\t},\n\n\t\t\t\t\t// func sleepTicks(timeout float64)\n\t\t\t\t\t\"runtime.sleepTicks\": (timeout) => {\n\t\t\t\t\t\t// Do not sleep, only reactivate scheduler after the given timeout.\n\t\t\t\t\t\tsetTimeout(this._inst.exports.go_scheduler, timeout);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func finalizeRef(v ref)\n\t\t\t\t\t\"syscall/js.finalizeRef\": (sp) => {\n\t\t\t\t\t\t// Note: TinyGo does not support finalizers so this should never be\n\t\t\t\t\t\t// called.\n\t\t\t\t\t\tconsole.error('syscall/js.finalizeRef not implemented');\n\t\t\t\t\t},\n\n\t\t\t\t\t// func stringVal(value string) ref\n\t\t\t\t\t\"syscall/js.stringVal\": (ret_ptr, value_ptr, value_len) => {\n\t\t\t\t\t\tconst s = loadString(value_ptr, value_len);\n\t\t\t\t\t\tstoreValue(ret_ptr, s);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueGet(v ref, p string) ref\n\t\t\t\t\t\"syscall/js.valueGet\": (retval, v_addr, p_ptr, p_len) => {\n\t\t\t\t\t\tlet prop = loadString(p_ptr, p_len);\n\t\t\t\t\t\tlet value = loadValue(v_addr);\n\t\t\t\t\t\tlet result = Reflect.get(value, prop);\n\t\t\t\t\t\tstoreValue(retval, result);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueSet(v ref, p string, x ref)\n\t\t\t\t\t\"syscall/js.valueSet\": (v_addr, p_ptr, p_len, x_addr) => {\n\t\t\t\t\t\tconst v = loadValue(v_addr);\n\t\t\t\t\t\tconst p = loadString(p_ptr, p_len);\n\t\t\t\t\t\tconst x = loadValue(x_addr);\n\t\t\t\t\t\tReflect.set(v, p, x);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueDelete(v ref, p string)\n\t\t\t\t\t\"syscall/js.valueDelete\": (v_addr, p_ptr, p_len) => {\n\t\t\t\t\t\tconst v = loadValue(v_addr);\n\t\t\t\t\t\tconst p = loadString(p_ptr, p_len);\n\t\t\t\t\t\tReflect.deleteProperty(v, p);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueIndex(v ref, i int) ref\n\t\t\t\t\t\"syscall/js.valueIndex\": (ret_addr, v_addr, i) => {\n\t\t\t\t\t\tstoreValue(ret_addr, Reflect.get(loadValue(v_addr), i));\n\t\t\t\t\t},\n\n\t\t\t\t\t// valueSetIndex(v ref, i int, x ref)\n\t\t\t\t\t\"syscall/js.valueSetIndex\": (v_addr, i, x_addr) => {\n\t\t\t\t\t\tReflect.set(loadValue(v_addr), i, loadValue(x_addr));\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueCall(v ref, m string, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueCall\": (ret_addr, v_addr, m_ptr, m_len, args_ptr, args_len, args_cap) => {\n\t\t\t\t\t\tconst v = loadValue(v_addr);\n\t\t\t\t\t\tconst name = loadString(m_ptr, m_len);\n\t\t\t\t\t\tconst args = loadSliceOfValues(args_ptr, args_len, args_cap);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst m = Reflect.get(v, name);\n\t\t\t\t\t\t\tstoreValue(ret_addr, Reflect.apply(m, v, args));\n\t\t\t\t\t\t\tmem().setUint8(ret_addr + 8, 1);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tstoreValue(ret_addr, err);\n\t\t\t\t\t\t\tmem().setUint8(ret_addr + 8, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueInvoke(v ref, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueInvoke\": (ret_addr, v_addr, args_ptr, args_len, args_cap) => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst v = loadValue(v_addr);\n\t\t\t\t\t\t\tconst args = loadSliceOfValues(args_ptr, args_len, args_cap);\n\t\t\t\t\t\t\tstoreValue(ret_addr, Reflect.apply(v, undefined, args));\n\t\t\t\t\t\t\tmem().setUint8(ret_addr + 8, 1);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tstoreValue(ret_addr, err);\n\t\t\t\t\t\t\tmem().setUint8(ret_addr + 8, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueNew(v ref, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueNew\": (ret_addr, v_addr, args_ptr, args_len, args_cap) => {\n\t\t\t\t\t\tconst v = loadValue(v_addr);\n\t\t\t\t\t\tconst args = loadSliceOfValues(args_ptr, args_len, args_cap);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tstoreValue(ret_addr, Reflect.construct(v, args));\n\t\t\t\t\t\t\tmem().setUint8(ret_addr + 8, 1);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tstoreValue(ret_addr, err);\n\t\t\t\t\t\t\tmem().setUint8(ret_addr+ 8, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueLength(v ref) int\n\t\t\t\t\t\"syscall/js.valueLength\": (v_addr) => {\n\t\t\t\t\t\treturn loadValue(v_addr).length;\n\t\t\t\t\t},\n\n\t\t\t\t\t// valuePrepareString(v ref) (ref, int)\n\t\t\t\t\t\"syscall/js.valuePrepareString\": (ret_addr, v_addr) => {\n\t\t\t\t\t\tconst s = String(loadValue(v_addr));\n\t\t\t\t\t\tconst str = encoder.encode(s);\n\t\t\t\t\t\tstoreValue(ret_addr, str);\n\t\t\t\t\t\tsetInt64(ret_addr + 8, str.length);\n\t\t\t\t\t},\n\n\t\t\t\t\t// valueLoadString(v ref, b []byte)\n\t\t\t\t\t\"syscall/js.valueLoadString\": (v_addr, slice_ptr, slice_len, slice_cap) => {\n\t\t\t\t\t\tconst str = loadValue(v_addr);\n\t\t\t\t\t\tloadSlice(slice_ptr, slice_len, slice_cap).set(str);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueInstanceOf(v ref, t ref) bool\n\t\t\t\t\t\"syscall/js.valueInstanceOf\": (v_addr, t_addr) => {\n \t\t\t\t\t\treturn loadValue(v_addr) instanceof loadValue(t_addr);\n\t\t\t\t\t},\n\n\t\t\t\t\t// func copyBytesToGo(dst []byte, src ref) (int, bool)\n\t\t\t\t\t\"syscall/js.copyBytesToGo\": (ret_addr, dest_addr, dest_len, dest_cap, source_addr) => {\n\t\t\t\t\t\tlet num_bytes_copied_addr = ret_addr;\n\t\t\t\t\t\tlet returned_status_addr = ret_addr + 4; // Address of returned boolean status variable\n\n\t\t\t\t\t\tconst dst = loadSlice(dest_addr, dest_len);\n\t\t\t\t\t\tconst src = loadValue(source_addr);\n\t\t\t\t\t\tif (!(src instanceof Uint8Array)) {\n\t\t\t\t\t\t\tmem().setUint8(returned_status_addr, 0); // Return \"not ok\" status\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst toCopy = src.subarray(0, dst.length);\n\t\t\t\t\t\tdst.set(toCopy);\n\t\t\t\t\t\tsetInt64(num_bytes_copied_addr, toCopy.length);\n\t\t\t\t\t\tmem().setUint8(returned_status_addr, 1); // Return \"ok\" status\n\t\t\t\t\t},\n\n\t\t\t\t\t// copyBytesToJS(dst ref, src []byte) (int, bool)\n\t\t\t\t\t// Originally copied from upstream Go project, then modified:\n\t\t\t\t\t//   https://github.com/golang/go/blob/3f995c3f3b43033013013e6c7ccc93a9b1411ca9/misc/wasm/wasm_exec.js#L404-L416\n\t\t\t\t\t\"syscall/js.copyBytesToJS\": (ret_addr, dest_addr, source_addr, source_len, source_cap) => {\n\t\t\t\t\t\tlet num_bytes_copied_addr = ret_addr;\n\t\t\t\t\t\tlet returned_status_addr = ret_addr + 4; // Address of returned boolean status variable\n\n\t\t\t\t\t\tconst dst = loadValue(dest_addr);\n\t\t\t\t\t\tconst src = loadSlice(source_addr, source_len);\n\t\t\t\t\t\tif (!(dst instanceof Uint8Array)) {\n\t\t\t\t\t\t\tmem().setUint8(returned_status_addr, 0); // Return \"not ok\" status\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst toCopy = src.subarray(0, dst.length);\n\t\t\t\t\t\tdst.set(toCopy);\n\t\t\t\t\t\tsetInt64(num_bytes_copied_addr, toCopy.length);\n\t\t\t\t\t\tmem().setUint8(returned_status_addr, 1); // Return \"ok\" status\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tasync run(instance) {\n\t\t\tthis._inst = instance;\n\t\t\tthis._values = [ // JS values that Go currently has references to, indexed by reference id\n\t\t\t\tNaN,\n\t\t\t\t0,\n\t\t\t\tnull,\n\t\t\t\ttrue,\n\t\t\t\tfalse,\n\t\t\t\tglobal,\n\t\t\t\tthis,\n\t\t\t];\n\t\t\tthis._goRefCounts = []; // number of references that Go has to a JS value, indexed by reference id\n\t\t\tthis._ids = new Map();  // mapping from JS values to reference ids\n\t\t\tthis._idPool = [];      // unused ids that have been garbage collected\n\t\t\tthis.exited = false;    // whether the Go program has exited\n\n\t\t\tconst mem = new DataView(this._inst.exports.memory.buffer)\n\n\t\t\twhile (true) {\n\t\t\t\tconst callbackPromise = new Promise((resolve) => {\n\t\t\t\t\tthis._resolveCallbackPromise = () => {\n\t\t\t\t\t\tif (this.exited) {\n\t\t\t\t\t\t\tthrow new Error(\"bad callback: Go program has already exited\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetTimeout(resolve, 0); // make sure it is asynchronous\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t\tthis._inst.exports._start();\n\t\t\t\tif (this.exited) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tawait callbackPromise;\n\t\t\t}\n\t\t}\n\n\t\t_resume() {\n\t\t\tif (this.exited) {\n\t\t\t\tthrow new Error(\"Go program has already exited\");\n\t\t\t}\n\t\t\tthis._inst.exports.resume();\n\t\t\tif (this.exited) {\n\t\t\t\tthis._resolveExitPromise();\n\t\t\t}\n\t\t}\n\n\t\t_makeFuncWrapper(id) {\n\t\t\tconst go = this;\n\t\t\treturn function () {\n\t\t\t\tconst event = { id: id, this: this, args: arguments };\n\t\t\t\tgo._pendingEvent = event;\n\t\t\t\tgo._resume();\n\t\t\t\treturn event.result;\n\t\t\t};\n\t\t}\n\t}\n\n\tif (\n\t\tglobal.require &&\n\t\tglobal.require.main === module &&\n\t\tglobal.process &&\n\t\tglobal.process.versions &&\n\t\t!global.process.versions.electron\n\t) {\n\t\tif (process.argv.length != 3) {\n\t\t\tconsole.error(\"usage: go_js_wasm_exec [wasm binary] [arguments]\");\n\t\t\tprocess.exit(1);\n\t\t}\n\n\t\tconst go = new Go();\n\t\tWebAssembly.instantiate(fs.readFileSync(process.argv[2]), go.importObject).then((result) => {\n\t\t\treturn go.run(result.instance);\n\t\t}).catch((err) => {\n\t\t\tconsole.error(err);\n\t\t\tprocess.exit(1);\n\t\t});\n\t}\n})();"),
}
var resourceWebglDebugJs = &gui.StaticResource{
	StaticName: "webgl-debug.js",
	StaticContent: []byte(
		"/*\n** Copyright (c) 2012 The Khronos Group Inc.\n**\n** Permission is hereby granted, free of charge, to any person obtaining a\n** copy of this software and/or associated documentation files (the\n** \"Materials\"), to deal in the Materials without restriction, including\n** without limitation the rights to use, copy, modify, merge, publish,\n** distribute, sublicense, and/or sell copies of the Materials, and to\n** permit persons to whom the Materials are furnished to do so, subject to\n** the following conditions:\n**\n** The above copyright notice and this permission notice shall be included\n** in all copies or substantial portions of the Materials.\n**\n** THE MATERIALS ARE PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.\n*/\n\n// Various functions for helping debug WebGL apps.\n\nWebGLDebugUtils = function() {\n\n    /**\n     * Wrapped logging function.\n     * @param {string} msg Message to log.\n     */\n    var log = function(msg) {\n      if (window.console && window.console.log) {\n        window.console.log(msg);\n      }\n    };\n    \n    /**\n     * Wrapped error logging function.\n     * @param {string} msg Message to log.\n     */\n    var error = function(msg) {\n      if (window.console && window.console.error) {\n        window.console.error(msg);\n      } else {\n        log(msg);\n      }\n    };\n    \n    \n    /**\n     * Which arguments are enums based on the number of arguments to the function.\n     * So\n     *    'texImage2D': {\n     *       9: { 0:true, 2:true, 6:true, 7:true },\n     *       6: { 0:true, 2:true, 3:true, 4:true },\n     *    },\n     *\n     * means if there are 9 arguments then 6 and 7 are enums, if there are 6\n     * arguments 3 and 4 are enums\n     *\n     * @type {!Object.<number, !Object.<number, string>}\n     */\n    var glValidEnumContexts = {\n      // Generic setters and getters\n    \n      'enable': {1: { 0:true }},\n      'disable': {1: { 0:true }},\n      'getParameter': {1: { 0:true }},\n    \n      // Rendering\n    \n      'drawArrays': {3:{ 0:true }},\n      'drawElements': {4:{ 0:true, 2:true }},\n    \n      // Shaders\n    \n      'createShader': {1: { 0:true }},\n      'getShaderParameter': {2: { 1:true }},\n      'getProgramParameter': {2: { 1:true }},\n      'getShaderPrecisionFormat': {2: { 0: true, 1:true }},\n    \n      // Vertex attributes\n    \n      'getVertexAttrib': {2: { 1:true }},\n      'vertexAttribPointer': {6: { 2:true }},\n    \n      // Textures\n    \n      'bindTexture': {2: { 0:true }},\n      'activeTexture': {1: { 0:true }},\n      'getTexParameter': {2: { 0:true, 1:true }},\n      'texParameterf': {3: { 0:true, 1:true }},\n      'texParameteri': {3: { 0:true, 1:true, 2:true }},\n      // texImage2D and texSubImage2D are defined below with WebGL 2 entrypoints\n      'copyTexImage2D': {8: { 0:true, 2:true }},\n      'copyTexSubImage2D': {8: { 0:true }},\n      'generateMipmap': {1: { 0:true }},\n      // compressedTexImage2D and compressedTexSubImage2D are defined below with WebGL 2 entrypoints\n    \n      // Buffer objects\n    \n      'bindBuffer': {2: { 0:true }},\n      // bufferData and bufferSubData are defined below with WebGL 2 entrypoints\n      'getBufferParameter': {2: { 0:true, 1:true }},\n    \n      // Renderbuffers and framebuffers\n    \n      'pixelStorei': {2: { 0:true, 1:true }},\n      // readPixels is defined below with WebGL 2 entrypoints\n      'bindRenderbuffer': {2: { 0:true }},\n      'bindFramebuffer': {2: { 0:true }},\n      'checkFramebufferStatus': {1: { 0:true }},\n      'framebufferRenderbuffer': {4: { 0:true, 1:true, 2:true }},\n      'framebufferTexture2D': {5: { 0:true, 1:true, 2:true }},\n      'getFramebufferAttachmentParameter': {3: { 0:true, 1:true, 2:true }},\n      'getRenderbufferParameter': {2: { 0:true, 1:true }},\n      'renderbufferStorage': {4: { 0:true, 1:true }},\n    \n      // Frame buffer operations (clear, blend, depth test, stencil)\n    \n      'clear': {1: { 0: { 'enumBitwiseOr': ['COLOR_BUFFER_BIT', 'DEPTH_BUFFER_BIT', 'STENCIL_BUFFER_BIT'] }}},\n      'depthFunc': {1: { 0:true }},\n      'blendFunc': {2: { 0:true, 1:true }},\n      'blendFuncSeparate': {4: { 0:true, 1:true, 2:true, 3:true }},\n      'blendEquation': {1: { 0:true }},\n      'blendEquationSeparate': {2: { 0:true, 1:true }},\n      'stencilFunc': {3: { 0:true }},\n      'stencilFuncSeparate': {4: { 0:true, 1:true }},\n      'stencilMaskSeparate': {2: { 0:true }},\n      'stencilOp': {3: { 0:true, 1:true, 2:true }},\n      'stencilOpSeparate': {4: { 0:true, 1:true, 2:true, 3:true }},\n    \n      // Culling\n    \n      'cullFace': {1: { 0:true }},\n      'frontFace': {1: { 0:true }},\n    \n      // ANGLE_instanced_arrays extension\n    \n      'drawArraysInstancedANGLE': {4: { 0:true }},\n      'drawElementsInstancedANGLE': {5: { 0:true, 2:true }},\n    \n      // EXT_blend_minmax extension\n    \n      'blendEquationEXT': {1: { 0:true }},\n    \n      // WebGL 2 Buffer objects\n    \n      'bufferData': {\n        3: { 0:true, 2:true }, // WebGL 1\n        4: { 0:true, 2:true }, // WebGL 2\n        5: { 0:true, 2:true }  // WebGL 2\n      },\n      'bufferSubData': {\n        3: { 0:true }, // WebGL 1\n        4: { 0:true }, // WebGL 2\n        5: { 0:true }  // WebGL 2\n      },\n      'copyBufferSubData': {5: { 0:true, 1:true }},\n      'getBufferSubData': {3: { 0:true }, 4: { 0:true }, 5: { 0:true }},\n    \n      // WebGL 2 Framebuffer objects\n    \n      'blitFramebuffer': {10: { 8: { 'enumBitwiseOr': ['COLOR_BUFFER_BIT', 'DEPTH_BUFFER_BIT', 'STENCIL_BUFFER_BIT'] }, 9:true }},\n      'framebufferTextureLayer': {5: { 0:true, 1:true }},\n      'invalidateFramebuffer': {2: { 0:true }},\n      'invalidateSubFramebuffer': {6: { 0:true }},\n      'readBuffer': {1: { 0:true }},\n    \n      // WebGL 2 Renderbuffer objects\n    \n      'getInternalformatParameter': {3: { 0:true, 1:true, 2:true }},\n      'renderbufferStorageMultisample': {5: { 0:true, 2:true }},\n    \n      // WebGL 2 Texture objects\n    \n      'texStorage2D': {5: { 0:true, 2:true }},\n      'texStorage3D': {6: { 0:true, 2:true }},\n      'texImage2D': {\n        9: { 0:true, 2:true, 6:true, 7:true }, // WebGL 1 & 2\n        6: { 0:true, 2:true, 3:true, 4:true }, // WebGL 1\n        10: { 0:true, 2:true, 6:true, 7:true } // WebGL 2\n      },\n      'texImage3D': {\n        10: { 0:true, 2:true, 7:true, 8:true },\n        11: { 0:true, 2:true, 7:true, 8:true }\n      },\n      'texSubImage2D': {\n        9: { 0:true, 6:true, 7:true }, // WebGL 1 & 2\n        7: { 0:true, 4:true, 5:true }, // WebGL 1\n        10: { 0:true, 6:true, 7:true } // WebGL 2\n      },\n      'texSubImage3D': {\n        11: { 0:true, 8:true, 9:true },\n        12: { 0:true, 8:true, 9:true }\n      },\n      'copyTexSubImage3D': {9: { 0:true }},\n      'compressedTexImage2D': {\n        7: { 0: true, 2:true }, // WebGL 1 & 2\n        8: { 0: true, 2:true }, // WebGL 2\n        9: { 0: true, 2:true }  // WebGL 2\n      },\n      'compressedTexImage3D': {\n        8: { 0: true, 2:true },\n        9: { 0: true, 2:true },\n        10: { 0: true, 2:true }\n      },\n      'compressedTexSubImage2D': {\n        8: { 0: true, 6:true }, // WebGL 1 & 2\n        9: { 0: true, 6:true }, // WebGL 2\n        10: { 0: true, 6:true } // WebGL 2\n      },\n      'compressedTexSubImage3D': {\n        10: { 0: true, 8:true },\n        11: { 0: true, 8:true },\n        12: { 0: true, 8:true }\n      },\n    \n      // WebGL 2 Vertex attribs\n    \n      'vertexAttribIPointer': {5: { 2:true }},\n    \n      // WebGL 2 Writing to the drawing buffer\n    \n      'drawArraysInstanced': {4: { 0:true }},\n      'drawElementsInstanced': {5: { 0:true, 2:true }},\n      'drawRangeElements': {6: { 0:true, 4:true }},\n    \n      // WebGL 2 Reading back pixels\n    \n      'readPixels': {\n        7: { 4:true, 5:true }, // WebGL 1 & 2\n        8: { 4:true, 5:true }  // WebGL 2\n      },\n    \n      // WebGL 2 Multiple Render Targets\n    \n      'clearBufferfv': {3: { 0:true }, 4: { 0:true }},\n      'clearBufferiv': {3: { 0:true }, 4: { 0:true }},\n      'clearBufferuiv': {3: { 0:true }, 4: { 0:true }},\n      'clearBufferfi': {4: { 0:true }},\n    \n      // WebGL 2 Query objects\n    \n      'beginQuery': {2: { 0:true }},\n      'endQuery': {1: { 0:true }},\n      'getQuery': {2: { 0:true, 1:true }},\n      'getQueryParameter': {2: { 1:true }},\n    \n      // WebGL 2 Sampler objects\n    \n      'samplerParameteri': {3: { 1:true, 2:true }},\n      'samplerParameterf': {3: { 1:true }},\n      'getSamplerParameter': {2: { 1:true }},\n    \n      // WebGL 2 Sync objects\n    \n      'fenceSync': {2: { 0:true, 1: { 'enumBitwiseOr': [] } }},\n      'clientWaitSync': {3: { 1: { 'enumBitwiseOr': ['SYNC_FLUSH_COMMANDS_BIT'] } }},\n      'waitSync': {3: { 1: { 'enumBitwiseOr': [] } }},\n      'getSyncParameter': {2: { 1:true }},\n    \n      // WebGL 2 Transform Feedback\n    \n      'bindTransformFeedback': {2: { 0:true }},\n      'beginTransformFeedback': {1: { 0:true }},\n      'transformFeedbackVaryings': {3: { 2:true }},\n    \n      // WebGL2 Uniform Buffer Objects and Transform Feedback Buffers\n    \n      'bindBufferBase': {3: { 0:true }},\n      'bindBufferRange': {5: { 0:true }},\n      'getIndexedParameter': {2: { 0:true }},\n      'getActiveUniforms': {3: { 2:true }},\n      'getActiveUniformBlockParameter': {3: { 2:true }}\n    };\n    \n    /**\n     * Map of numbers to names.\n     * @type {Object}\n     */\n    var glEnums = null;\n    \n    /**\n     * Map of names to numbers.\n     * @type {Object}\n     */\n    var enumStringToValue = null;\n    \n    /**\n     * Initializes this module. Safe to call more than once.\n     * @param {!WebGLRenderingContext} ctx A WebGL context. If\n     *    you have more than one context it doesn't matter which one\n     *    you pass in, it is only used to pull out constants.\n     */\n    function init(ctx) {\n      if (glEnums == null) {\n        glEnums = { };\n        enumStringToValue = { };\n        for (var propertyName in ctx) {\n          if (typeof ctx[propertyName] == 'number') {\n            glEnums[ctx[propertyName]] = propertyName;\n            enumStringToValue[propertyName] = ctx[propertyName];\n          }\n        }\n      }\n    }\n    \n    /**\n     * Checks the utils have been initialized.\n     */\n    function checkInit() {\n      if (glEnums == null) {\n        throw 'WebGLDebugUtils.init(ctx) not called';\n      }\n    }\n    \n    /**\n     * Returns true or false if value matches any WebGL enum\n     * @param {*} value Value to check if it might be an enum.\n     * @return {boolean} True if value matches one of the WebGL defined enums\n     */\n    function mightBeEnum(value) {\n      checkInit();\n      return (glEnums[value] !== undefined);\n    }\n    \n    /**\n     * Gets an string version of an WebGL enum.\n     *\n     * Example:\n     *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());\n     *\n     * @param {number} value Value to return an enum for\n     * @return {string} The string version of the enum.\n     */\n    function glEnumToString(value) {\n      checkInit();\n      var name = glEnums[value];\n      return (name !== undefined) ? (\"gl.\" + name) :\n          (\"/*UNKNOWN WebGL ENUM*/ 0x\" + value.toString(16) + \"\");\n    }\n    \n    /**\n     * Returns the string version of a WebGL argument.\n     * Attempts to convert enum arguments to strings.\n     * @param {string} functionName the name of the WebGL function.\n     * @param {number} numArgs the number of arguments passed to the function.\n     * @param {number} argumentIndx the index of the argument.\n     * @param {*} value The value of the argument.\n     * @return {string} The value as a string.\n     */\n    function glFunctionArgToString(functionName, numArgs, argumentIndex, value) {\n      var funcInfo = glValidEnumContexts[functionName];\n      if (funcInfo !== undefined) {\n        var funcInfo = funcInfo[numArgs];\n        if (funcInfo !== undefined) {\n          if (funcInfo[argumentIndex]) {\n            if (typeof funcInfo[argumentIndex] === 'object' &&\n                funcInfo[argumentIndex]['enumBitwiseOr'] !== undefined) {\n              var enums = funcInfo[argumentIndex]['enumBitwiseOr'];\n              var orResult = 0;\n              var orEnums = [];\n              for (var i = 0; i < enums.length; ++i) {\n                var enumValue = enumStringToValue[enums[i]];\n                if ((value & enumValue) !== 0) {\n                  orResult |= enumValue;\n                  orEnums.push(glEnumToString(enumValue));\n                }\n              }\n              if (orResult === value) {\n                return orEnums.join(' | ');\n              } else {\n                return glEnumToString(value);\n              }\n            } else {\n              return glEnumToString(value);\n            }\n          }\n        }\n      }\n      if (value === null) {\n        return \"null\";\n      } else if (value === undefined) {\n        return \"undefined\";\n      } else {\n        return value.toString();\n      }\n    }\n    \n    /**\n     * Converts the arguments of a WebGL function to a string.\n     * Attempts to convert enum arguments to strings.\n     *\n     * @param {string} functionName the name of the WebGL function.\n     * @param {number} args The arguments.\n     * @return {string} The arguments as a string.\n     */\n    function glFunctionArgsToString(functionName, args) {\n      // apparently we can't do args.join(\",\");\n      var argStr = \"\";\n      var numArgs = args.length;\n      for (var ii = 0; ii < numArgs; ++ii) {\n        argStr += ((ii == 0) ? '' : ', ') +\n            glFunctionArgToString(functionName, numArgs, ii, args[ii]);\n      }\n      return argStr;\n    };\n    \n    \n    function makePropertyWrapper(wrapper, original, propertyName) {\n      //log(\"wrap prop: \" + propertyName);\n      wrapper.__defineGetter__(propertyName, function() {\n        return original[propertyName];\n      });\n      // TODO(gmane): this needs to handle properties that take more than\n      // one value?\n      wrapper.__defineSetter__(propertyName, function(value) {\n        //log(\"set: \" + propertyName);\n        original[propertyName] = value;\n      });\n    }\n    \n    // Makes a function that calls a function on another object.\n    function makeFunctionWrapper(original, functionName) {\n      //log(\"wrap fn: \" + functionName);\n      var f = original[functionName];\n      return function() {\n        //log(\"call: \" + functionName);\n        var result = f.apply(original, arguments);\n        return result;\n      };\n    }\n    \n    /**\n     * Given a WebGL context returns a wrapped context that calls\n     * gl.getError after every command and calls a function if the\n     * result is not gl.NO_ERROR.\n     *\n     * @param {!WebGLRenderingContext} ctx The webgl context to\n     *        wrap.\n     * @param {!function(err, funcName, args): void} opt_onErrorFunc\n     *        The function to call when gl.getError returns an\n     *        error. If not specified the default function calls\n     *        console.log with a message.\n     * @param {!function(funcName, args): void} opt_onFunc The\n     *        function to call when each webgl function is called.\n     *        You can use this to log all calls for example.\n     * @param {!WebGLRenderingContext} opt_err_ctx The webgl context\n     *        to call getError on if different than ctx.\n     */\n    function makeDebugContext(ctx, opt_onErrorFunc, opt_onFunc, opt_err_ctx) {\n      opt_err_ctx = opt_err_ctx || ctx;\n      init(ctx);\n      opt_onErrorFunc = opt_onErrorFunc || function(err, functionName, args) {\n            // apparently we can't do args.join(\",\");\n            var argStr = \"\";\n            var numArgs = args.length;\n            for (var ii = 0; ii < numArgs; ++ii) {\n              argStr += ((ii == 0) ? '' : ', ') +\n                  glFunctionArgToString(functionName, numArgs, ii, args[ii]);\n            }\n            error(\"WebGL error \"+ glEnumToString(err) + \" in \"+ functionName +\n                  \"(\" + argStr + \")\");\n          };\n    \n      // Holds booleans for each GL error so after we get the error ourselves\n      // we can still return it to the client app.\n      var glErrorShadow = { };\n    \n      // Makes a function that calls a WebGL function and then calls getError.\n      function makeErrorWrapper(ctx, functionName) {\n        return function() {\n          if (opt_onFunc) {\n            opt_onFunc(functionName, arguments);\n          }\n          var result = ctx[functionName].apply(ctx, arguments);\n          var err = opt_err_ctx.getError();\n          if (err != 0) {\n            glErrorShadow[err] = true;\n            opt_onErrorFunc(err, functionName, arguments);\n          }\n          return result;\n        };\n      }\n    \n      // Make a an object that has a copy of every property of the WebGL context\n      // but wraps all functions.\n      var wrapper = {};\n      for (var propertyName in ctx) {\n        if (typeof ctx[propertyName] == 'function') {\n          if (propertyName != 'getExtension') {\n            wrapper[propertyName] = makeErrorWrapper(ctx, propertyName);\n          } else {\n            var wrapped = makeErrorWrapper(ctx, propertyName);\n            wrapper[propertyName] = function () {\n              var result = wrapped.apply(ctx, arguments);\n              if (!result) {\n                return null;\n              }\n              return makeDebugContext(result, opt_onErrorFunc, opt_onFunc, opt_err_ctx);\n            };\n          }\n        } else {\n          makePropertyWrapper(wrapper, ctx, propertyName);\n        }\n      }\n    \n      // Override the getError function with one that returns our saved results.\n      wrapper.getError = function() {\n        for (var err in glErrorShadow) {\n          if (glErrorShadow.hasOwnProperty(err)) {\n            if (glErrorShadow[err]) {\n              glErrorShadow[err] = false;\n              return err;\n            }\n          }\n        }\n        return ctx.NO_ERROR;\n      };\n    \n      return wrapper;\n    }\n    \n    function resetToInitialState(ctx) {\n      var isWebGL2RenderingContext = !!ctx.createTransformFeedback;\n    \n      if (isWebGL2RenderingContext) {\n        ctx.bindVertexArray(null);\n      }\n    \n      var numAttribs = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS);\n      var tmp = ctx.createBuffer();\n      ctx.bindBuffer(ctx.ARRAY_BUFFER, tmp);\n      for (var ii = 0; ii < numAttribs; ++ii) {\n        ctx.disableVertexAttribArray(ii);\n        ctx.vertexAttribPointer(ii, 4, ctx.FLOAT, false, 0, 0);\n        ctx.vertexAttrib1f(ii, 0);\n        if (isWebGL2RenderingContext) {\n          ctx.vertexAttribDivisor(ii, 0);\n        }\n      }\n      ctx.deleteBuffer(tmp);\n    \n      var numTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);\n      for (var ii = 0; ii < numTextureUnits; ++ii) {\n        ctx.activeTexture(ctx.TEXTURE0 + ii);\n        ctx.bindTexture(ctx.TEXTURE_CUBE_MAP, null);\n        ctx.bindTexture(ctx.TEXTURE_2D, null);\n        if (isWebGL2RenderingContext) {\n          ctx.bindTexture(ctx.TEXTURE_2D_ARRAY, null);\n          ctx.bindTexture(ctx.TEXTURE_3D, null);\n          ctx.bindSampler(ii, null);\n        }\n      }\n    \n      ctx.activeTexture(ctx.TEXTURE0);\n      ctx.useProgram(null);\n      ctx.bindBuffer(ctx.ARRAY_BUFFER, null);\n      ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);\n      ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);\n      ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);\n      ctx.disable(ctx.BLEND);\n      ctx.disable(ctx.CULL_FACE);\n      ctx.disable(ctx.DEPTH_TEST);\n      ctx.disable(ctx.DITHER);\n      ctx.disable(ctx.SCISSOR_TEST);\n      ctx.blendColor(0, 0, 0, 0);\n      ctx.blendEquation(ctx.FUNC_ADD);\n      ctx.blendFunc(ctx.ONE, ctx.ZERO);\n      ctx.clearColor(0, 0, 0, 0);\n      ctx.clearDepth(1);\n      ctx.clearStencil(-1);\n      ctx.colorMask(true, true, true, true);\n      ctx.cullFace(ctx.BACK);\n      ctx.depthFunc(ctx.LESS);\n      ctx.depthMask(true);\n      ctx.depthRange(0, 1);\n      ctx.frontFace(ctx.CCW);\n      ctx.hint(ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE);\n      ctx.lineWidth(1);\n      ctx.pixelStorei(ctx.PACK_ALIGNMENT, 4);\n      ctx.pixelStorei(ctx.UNPACK_ALIGNMENT, 4);\n      ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, false);\n      ctx.pixelStorei(ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n      // TODO: Delete this IF.\n      if (ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL) {\n        ctx.pixelStorei(ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL);\n      }\n      ctx.polygonOffset(0, 0);\n      ctx.sampleCoverage(1, false);\n      ctx.scissor(0, 0, ctx.canvas.width, ctx.canvas.height);\n      ctx.stencilFunc(ctx.ALWAYS, 0, 0xFFFFFFFF);\n      ctx.stencilMask(0xFFFFFFFF);\n      ctx.stencilOp(ctx.KEEP, ctx.KEEP, ctx.KEEP);\n      ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);\n      ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT);\n    \n      if (isWebGL2RenderingContext) {\n        ctx.drawBuffers([ctx.BACK]);\n        ctx.readBuffer(ctx.BACK);\n        ctx.bindBuffer(ctx.COPY_READ_BUFFER, null);\n        ctx.bindBuffer(ctx.COPY_WRITE_BUFFER, null);\n        ctx.bindBuffer(ctx.PIXEL_PACK_BUFFER, null);\n        ctx.bindBuffer(ctx.PIXEL_UNPACK_BUFFER, null);\n        var numTransformFeedbacks = ctx.getParameter(ctx.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS);\n        for (var ii = 0; ii < numTransformFeedbacks; ++ii) {\n          ctx.bindBufferBase(ctx.TRANSFORM_FEEDBACK_BUFFER, ii, null);\n        }\n        var numUBOs = ctx.getParameter(ctx.MAX_UNIFORM_BUFFER_BINDINGS);\n        for (var ii = 0; ii < numUBOs; ++ii) {\n          ctx.bindBufferBase(ctx.UNIFORM_BUFFER, ii, null);\n        }\n        ctx.disable(ctx.RASTERIZER_DISCARD);\n        ctx.pixelStorei(ctx.UNPACK_IMAGE_HEIGHT, 0);\n        ctx.pixelStorei(ctx.UNPACK_SKIP_IMAGES, 0);\n        ctx.pixelStorei(ctx.UNPACK_ROW_LENGTH, 0);\n        ctx.pixelStorei(ctx.UNPACK_SKIP_ROWS, 0);\n        ctx.pixelStorei(ctx.UNPACK_SKIP_PIXELS, 0);\n        ctx.pixelStorei(ctx.PACK_ROW_LENGTH, 0);\n        ctx.pixelStorei(ctx.PACK_SKIP_ROWS, 0);\n        ctx.pixelStorei(ctx.PACK_SKIP_PIXELS, 0);\n        ctx.hint(ctx.FRAGMENT_SHADER_DERIVATIVE_HINT, ctx.DONT_CARE);\n      }\n    \n      // TODO: This should NOT be needed but Firefox fails with 'hint'\n      while(ctx.getError());\n    }\n    \n    function makeLostContextSimulatingCanvas(canvas) {\n      var unwrappedContext_;\n      var wrappedContext_;\n      var onLost_ = [];\n      var onRestored_ = [];\n      var wrappedContext_ = {};\n      var contextId_ = 1;\n      var contextLost_ = false;\n      var resourceId_ = 0;\n      var resourceDb_ = [];\n      var numCallsToLoseContext_ = 0;\n      var numCalls_ = 0;\n      var canRestore_ = false;\n      var restoreTimeout_ = 0;\n      var isWebGL2RenderingContext;\n    \n      // Holds booleans for each GL error so can simulate errors.\n      var glErrorShadow_ = { };\n    \n      canvas.getContext = function(f) {\n        return function() {\n          var ctx = f.apply(canvas, arguments);\n          // Did we get a context and is it a WebGL context?\n          if ((ctx instanceof WebGLRenderingContext) || (window.WebGL2RenderingContext && (ctx instanceof WebGL2RenderingContext))) {\n            if (ctx != unwrappedContext_) {\n              if (unwrappedContext_) {\n                throw \"got different context\"\n              }\n              isWebGL2RenderingContext = window.WebGL2RenderingContext && (ctx instanceof WebGL2RenderingContext);\n              unwrappedContext_ = ctx;\n              wrappedContext_ = makeLostContextSimulatingContext(unwrappedContext_);\n            }\n            return wrappedContext_;\n          }\n          return ctx;\n        }\n      }(canvas.getContext);\n    \n      function wrapEvent(listener) {\n        if (typeof(listener) == \"function\") {\n          return listener;\n        } else {\n          return function(info) {\n            listener.handleEvent(info);\n          }\n        }\n      }\n    \n      var addOnContextLostListener = function(listener) {\n        onLost_.push(wrapEvent(listener));\n      };\n    \n      var addOnContextRestoredListener = function(listener) {\n        onRestored_.push(wrapEvent(listener));\n      };\n    \n    \n      function wrapAddEventListener(canvas) {\n        var f = canvas.addEventListener;\n        canvas.addEventListener = function(type, listener, bubble) {\n          switch (type) {\n            case 'webglcontextlost':\n              addOnContextLostListener(listener);\n              break;\n            case 'webglcontextrestored':\n              addOnContextRestoredListener(listener);\n              break;\n            default:\n              f.apply(canvas, arguments);\n          }\n        };\n      }\n    \n      wrapAddEventListener(canvas);\n    \n      canvas.loseContext = function() {\n        if (!contextLost_) {\n          contextLost_ = true;\n          numCallsToLoseContext_ = 0;\n          ++contextId_;\n          while (unwrappedContext_.getError());\n          clearErrors();\n          glErrorShadow_[unwrappedContext_.CONTEXT_LOST_WEBGL] = true;\n          var event = makeWebGLContextEvent(\"context lost\");\n          var callbacks = onLost_.slice();\n          setTimeout(function() {\n              //log(\"numCallbacks:\" + callbacks.length);\n              for (var ii = 0; ii < callbacks.length; ++ii) {\n                //log(\"calling callback:\" + ii);\n                callbacks[ii](event);\n              }\n              if (restoreTimeout_ >= 0) {\n                setTimeout(function() {\n                    canvas.restoreContext();\n                  }, restoreTimeout_);\n              }\n            }, 0);\n        }\n      };\n    \n      canvas.restoreContext = function() {\n        if (contextLost_) {\n          if (onRestored_.length) {\n            setTimeout(function() {\n                if (!canRestore_) {\n                  throw \"can not restore. webglcontestlost listener did not call event.preventDefault\";\n                }\n                freeResources();\n                resetToInitialState(unwrappedContext_);\n                contextLost_ = false;\n                numCalls_ = 0;\n                canRestore_ = false;\n                var callbacks = onRestored_.slice();\n                var event = makeWebGLContextEvent(\"context restored\");\n                for (var ii = 0; ii < callbacks.length; ++ii) {\n                  callbacks[ii](event);\n                }\n              }, 0);\n          }\n        }\n      };\n    \n      canvas.loseContextInNCalls = function(numCalls) {\n        if (contextLost_) {\n          throw \"You can not ask a lost contet to be lost\";\n        }\n        numCallsToLoseContext_ = numCalls_ + numCalls;\n      };\n    \n      canvas.getNumCalls = function() {\n        return numCalls_;\n      };\n    \n      canvas.setRestoreTimeout = function(timeout) {\n        restoreTimeout_ = timeout;\n      };\n    \n      function isWebGLObject(obj) {\n        //return false;\n        return (obj instanceof WebGLBuffer ||\n                obj instanceof WebGLFramebuffer ||\n                obj instanceof WebGLProgram ||\n                obj instanceof WebGLRenderbuffer ||\n                obj instanceof WebGLShader ||\n                obj instanceof WebGLTexture);\n      }\n    \n      function checkResources(args) {\n        for (var ii = 0; ii < args.length; ++ii) {\n          var arg = args[ii];\n          if (isWebGLObject(arg)) {\n            return arg.__webglDebugContextLostId__ == contextId_;\n          }\n        }\n        return true;\n      }\n    \n      function clearErrors() {\n        var k = Object.keys(glErrorShadow_);\n        for (var ii = 0; ii < k.length; ++ii) {\n          delete glErrorShadow_[k[ii]];\n        }\n      }\n    \n      function loseContextIfTime() {\n        ++numCalls_;\n        if (!contextLost_) {\n          if (numCallsToLoseContext_ == numCalls_) {\n            canvas.loseContext();\n          }\n        }\n      }\n    \n      // Makes a function that simulates WebGL when out of context.\n      function makeLostContextFunctionWrapper(ctx, functionName) {\n        var f = ctx[functionName];\n        return function() {\n          // log(\"calling:\" + functionName);\n          // Only call the functions if the context is not lost.\n          loseContextIfTime();\n          if (!contextLost_) {\n            //if (!checkResources(arguments)) {\n            //  glErrorShadow_[wrappedContext_.INVALID_OPERATION] = true;\n            //  return;\n            //}\n            var result = f.apply(ctx, arguments);\n            return result;\n          }\n        };\n      }\n    \n      function freeResources() {\n        for (var ii = 0; ii < resourceDb_.length; ++ii) {\n          var resource = resourceDb_[ii];\n          if (resource instanceof WebGLBuffer) {\n            unwrappedContext_.deleteBuffer(resource);\n          } else if (resource instanceof WebGLFramebuffer) {\n            unwrappedContext_.deleteFramebuffer(resource);\n          } else if (resource instanceof WebGLProgram) {\n            unwrappedContext_.deleteProgram(resource);\n          } else if (resource instanceof WebGLRenderbuffer) {\n            unwrappedContext_.deleteRenderbuffer(resource);\n          } else if (resource instanceof WebGLShader) {\n            unwrappedContext_.deleteShader(resource);\n          } else if (resource instanceof WebGLTexture) {\n            unwrappedContext_.deleteTexture(resource);\n          }\n          else if (isWebGL2RenderingContext) {\n            if (resource instanceof WebGLQuery) {\n              unwrappedContext_.deleteQuery(resource);\n            } else if (resource instanceof WebGLSampler) {\n              unwrappedContext_.deleteSampler(resource);\n            } else if (resource instanceof WebGLSync) {\n              unwrappedContext_.deleteSync(resource);\n            } else if (resource instanceof WebGLTransformFeedback) {\n              unwrappedContext_.deleteTransformFeedback(resource);\n            } else if (resource instanceof WebGLVertexArrayObject) {\n              unwrappedContext_.deleteVertexArray(resource);\n            }\n          }\n        }\n      }\n    \n      function makeWebGLContextEvent(statusMessage) {\n        return {\n          statusMessage: statusMessage,\n          preventDefault: function() {\n              canRestore_ = true;\n            }\n        };\n      }\n    \n      return canvas;\n    \n      function makeLostContextSimulatingContext(ctx) {\n        // copy all functions and properties to wrapper\n        for (var propertyName in ctx) {\n          if (typeof ctx[propertyName] == 'function') {\n             wrappedContext_[propertyName] = makeLostContextFunctionWrapper(\n                 ctx, propertyName);\n           } else {\n             makePropertyWrapper(wrappedContext_, ctx, propertyName);\n           }\n        }\n    \n        // Wrap a few functions specially.\n        wrappedContext_.getError = function() {\n          loseContextIfTime();\n          if (!contextLost_) {\n            var err;\n            while (err = unwrappedContext_.getError()) {\n              glErrorShadow_[err] = true;\n            }\n          }\n          for (var err in glErrorShadow_) {\n            if (glErrorShadow_[err]) {\n              delete glErrorShadow_[err];\n              return err;\n            }\n          }\n          return wrappedContext_.NO_ERROR;\n        };\n    \n        var creationFunctions = [\n          \"createBuffer\",\n          \"createFramebuffer\",\n          \"createProgram\",\n          \"createRenderbuffer\",\n          \"createShader\",\n          \"createTexture\"\n        ];\n        if (isWebGL2RenderingContext) {\n          creationFunctions.push(\n            \"createQuery\",\n            \"createSampler\",\n            \"fenceSync\",\n            \"createTransformFeedback\",\n            \"createVertexArray\"\n          );\n        }\n        for (var ii = 0; ii < creationFunctions.length; ++ii) {\n          var functionName = creationFunctions[ii];\n          wrappedContext_[functionName] = function(f) {\n            return function() {\n              loseContextIfTime();\n              if (contextLost_) {\n                return null;\n              }\n              var obj = f.apply(ctx, arguments);\n              obj.__webglDebugContextLostId__ = contextId_;\n              resourceDb_.push(obj);\n              return obj;\n            };\n          }(ctx[functionName]);\n        }\n    \n        var functionsThatShouldReturnNull = [\n          \"getActiveAttrib\",\n          \"getActiveUniform\",\n          \"getBufferParameter\",\n          \"getContextAttributes\",\n          \"getAttachedShaders\",\n          \"getFramebufferAttachmentParameter\",\n          \"getParameter\",\n          \"getProgramParameter\",\n          \"getProgramInfoLog\",\n          \"getRenderbufferParameter\",\n          \"getShaderParameter\",\n          \"getShaderInfoLog\",\n          \"getShaderSource\",\n          \"getTexParameter\",\n          \"getUniform\",\n          \"getUniformLocation\",\n          \"getVertexAttrib\"\n        ];\n        if (isWebGL2RenderingContext) {\n          functionsThatShouldReturnNull.push(\n            \"getInternalformatParameter\",\n            \"getQuery\",\n            \"getQueryParameter\",\n            \"getSamplerParameter\",\n            \"getSyncParameter\",\n            \"getTransformFeedbackVarying\",\n            \"getIndexedParameter\",\n            \"getUniformIndices\",\n            \"getActiveUniforms\",\n            \"getActiveUniformBlockParameter\",\n            \"getActiveUniformBlockName\"\n          );\n        }\n        for (var ii = 0; ii < functionsThatShouldReturnNull.length; ++ii) {\n          var functionName = functionsThatShouldReturnNull[ii];\n          wrappedContext_[functionName] = function(f) {\n            return function() {\n              loseContextIfTime();\n              if (contextLost_) {\n                return null;\n              }\n              return f.apply(ctx, arguments);\n            }\n          }(wrappedContext_[functionName]);\n        }\n    \n        var isFunctions = [\n          \"isBuffer\",\n          \"isEnabled\",\n          \"isFramebuffer\",\n          \"isProgram\",\n          \"isRenderbuffer\",\n          \"isShader\",\n          \"isTexture\"\n        ];\n        if (isWebGL2RenderingContext) {\n          isFunctions.push(\n            \"isQuery\",\n            \"isSampler\",\n            \"isSync\",\n            \"isTransformFeedback\",\n            \"isVertexArray\"\n          );\n        }\n        for (var ii = 0; ii < isFunctions.length; ++ii) {\n          var functionName = isFunctions[ii];\n          wrappedContext_[functionName] = function(f) {\n            return function() {\n              loseContextIfTime();\n              if (contextLost_) {\n                return false;\n              }\n              return f.apply(ctx, arguments);\n            }\n          }(wrappedContext_[functionName]);\n        }\n    \n        wrappedContext_.checkFramebufferStatus = function(f) {\n          return function() {\n            loseContextIfTime();\n            if (contextLost_) {\n              return wrappedContext_.FRAMEBUFFER_UNSUPPORTED;\n            }\n            return f.apply(ctx, arguments);\n          };\n        }(wrappedContext_.checkFramebufferStatus);\n    \n        wrappedContext_.getAttribLocation = function(f) {\n          return function() {\n            loseContextIfTime();\n            if (contextLost_) {\n              return -1;\n            }\n            return f.apply(ctx, arguments);\n          };\n        }(wrappedContext_.getAttribLocation);\n    \n        wrappedContext_.getVertexAttribOffset = function(f) {\n          return function() {\n            loseContextIfTime();\n            if (contextLost_) {\n              return 0;\n            }\n            return f.apply(ctx, arguments);\n          };\n        }(wrappedContext_.getVertexAttribOffset);\n    \n        wrappedContext_.isContextLost = function() {\n          return contextLost_;\n        };\n    \n        if (isWebGL2RenderingContext) {\n          wrappedContext_.getFragDataLocation = function(f) {\n            return function() {\n              loseContextIfTime();\n              if (contextLost_) {\n                return -1;\n              }\n              return f.apply(ctx, arguments);\n            };\n          }(wrappedContext_.getFragDataLocation);\n    \n          wrappedContext_.clientWaitSync = function(f) {\n            return function() {\n              loseContextIfTime();\n              if (contextLost_) {\n                return wrappedContext_.WAIT_FAILED;\n              }\n              return f.apply(ctx, arguments);\n            };\n          }(wrappedContext_.clientWaitSync);\n    \n          wrappedContext_.getUniformBlockIndex = function(f) {\n            return function() {\n              loseContextIfTime();\n              if (contextLost_) {\n                return wrappedContext_.INVALID_INDEX;\n              }\n              return f.apply(ctx, arguments);\n            };\n          }(wrappedContext_.getUniformBlockIndex);\n        }\n    \n        return wrappedContext_;\n      }\n    }\n    \n    return {\n      /**\n       * Initializes this module. Safe to call more than once.\n       * @param {!WebGLRenderingContext} ctx A WebGL context. If\n       *    you have more than one context it doesn't matter which one\n       *    you pass in, it is only used to pull out constants.\n       */\n      'init': init,\n    \n      /**\n       * Returns true or false if value matches any WebGL enum\n       * @param {*} value Value to check if it might be an enum.\n       * @return {boolean} True if value matches one of the WebGL defined enums\n       */\n      'mightBeEnum': mightBeEnum,\n    \n      /**\n       * Gets an string version of an WebGL enum.\n       *\n       * Example:\n       *   WebGLDebugUtil.init(ctx);\n       *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());\n       *\n       * @param {number} value Value to return an enum for\n       * @return {string} The string version of the enum.\n       */\n      'glEnumToString': glEnumToString,\n    \n      /**\n       * Converts the argument of a WebGL function to a string.\n       * Attempts to convert enum arguments to strings.\n       *\n       * Example:\n       *   WebGLDebugUtil.init(ctx);\n       *   var str = WebGLDebugUtil.glFunctionArgToString('bindTexture', 2, 0, gl.TEXTURE_2D);\n       *\n       * would return 'TEXTURE_2D'\n       *\n       * @param {string} functionName the name of the WebGL function.\n       * @param {number} numArgs The number of arguments\n       * @param {number} argumentIndx the index of the argument.\n       * @param {*} value The value of the argument.\n       * @return {string} The value as a string.\n       */\n      'glFunctionArgToString': glFunctionArgToString,\n    \n      /**\n       * Converts the arguments of a WebGL function to a string.\n       * Attempts to convert enum arguments to strings.\n       *\n       * @param {string} functionName the name of the WebGL function.\n       * @param {number} args The arguments.\n       * @return {string} The arguments as a string.\n       */\n      'glFunctionArgsToString': glFunctionArgsToString,\n    \n      /**\n       * Given a WebGL context returns a wrapped context that calls\n       * gl.getError after every command and calls a function if the\n       * result is not NO_ERROR.\n       *\n       * You can supply your own function if you want. For example, if you'd like\n       * an exception thrown on any GL error you could do this\n       *\n       *    function throwOnGLError(err, funcName, args) {\n       *      throw WebGLDebugUtils.glEnumToString(err) +\n       *            \" was caused by call to \" + funcName;\n       *    };\n       *\n       *    ctx = WebGLDebugUtils.makeDebugContext(\n       *        canvas.getContext(\"webgl\"), throwOnGLError);\n       *\n       * @param {!WebGLRenderingContext} ctx The webgl context to wrap.\n       * @param {!function(err, funcName, args): void} opt_onErrorFunc The function\n       *     to call when gl.getError returns an error. If not specified the default\n       *     function calls console.log with a message.\n       * @param {!function(funcName, args): void} opt_onFunc The\n       *     function to call when each webgl function is called. You\n       *     can use this to log all calls for example.\n       */\n      'makeDebugContext': makeDebugContext,\n    \n      /**\n       * Given a canvas element returns a wrapped canvas element that will\n       * simulate lost context. The canvas returned adds the following functions.\n       *\n       * loseContext:\n       *   simulates a lost context event.\n       *\n       * restoreContext:\n       *   simulates the context being restored.\n       *\n       * lostContextInNCalls:\n       *   loses the context after N gl calls.\n       *\n       * getNumCalls:\n       *   tells you how many gl calls there have been so far.\n       *\n       * setRestoreTimeout:\n       *   sets the number of milliseconds until the context is restored\n       *   after it has been lost. Defaults to 0. Pass -1 to prevent\n       *   automatic restoring.\n       *\n       * @param {!Canvas} canvas The canvas element to wrap.\n       */\n      'makeLostContextSimulatingCanvas': makeLostContextSimulatingCanvas,\n    \n      /**\n       * Resets a context to the initial state.\n       * @param {!WebGLRenderingContext} ctx The webgl context to\n       *     reset.\n       */\n      'resetToInitialState': resetToInitialState\n    };\n    \n    }();\n    "),
}
var resourceXcassetsJSON = &gui.StaticResource{
	StaticName: "xcassets.JSON",
	StaticContent: []byte(
		"{\n  \"images\" : [\n    {\n      \"idiom\" : \"iphone\",\n      \"scale\" : \"2x\",\n      \"size\" : \"20x20\"\n    },\n    {\n      \"idiom\" : \"iphone\",\n      \"scale\" : \"3x\",\n      \"size\" : \"20x20\"\n    },\n    {\n      \"idiom\" : \"iphone\",\n      \"scale\" : \"2x\",\n      \"size\" : \"29x29\"\n    },\n    {\n      \"idiom\" : \"iphone\",\n      \"scale\" : \"3x\",\n      \"size\" : \"29x29\"\n    },\n    {\n      \"idiom\" : \"iphone\",\n      \"scale\" : \"2x\",\n      \"size\" : \"40x40\"\n    },\n    {\n      \"idiom\" : \"iphone\",\n      \"scale\" : \"3x\",\n      \"size\" : \"40x40\"\n    },\n    {\n      \"filename\" : \"Icon_120.png\",\n      \"idiom\" : \"iphone\",\n      \"scale\" : \"2x\",\n      \"size\" : \"60x60\"\n    },\n    {\n      \"filename\" : \"Icon_180.png\",\n      \"idiom\" : \"iphone\",\n      \"scale\" : \"3x\",\n      \"size\" : \"60x60\"\n    },\n    {\n      \"idiom\" : \"ipad\",\n      \"scale\" : \"1x\",\n      \"size\" : \"20x20\"\n    },\n    {\n      \"idiom\" : \"ipad\",\n      \"scale\" : \"2x\",\n      \"size\" : \"20x20\"\n    },\n    {\n      \"idiom\" : \"ipad\",\n      \"scale\" : \"1x\",\n      \"size\" : \"29x29\"\n    },\n    {\n      \"idiom\" : \"ipad\",\n      \"scale\" : \"2x\",\n      \"size\" : \"29x29\"\n    },\n    {\n      \"idiom\" : \"ipad\",\n      \"scale\" : \"1x\",\n      \"size\" : \"40x40\"\n    },\n    {\n      \"idiom\" : \"ipad\",\n      \"scale\" : \"2x\",\n      \"size\" : \"40x40\"\n    },\n    {\n      \"filename\" : \"Icon_76.png\",\n      \"idiom\" : \"ipad\",\n      \"scale\" : \"1x\",\n      \"size\" : \"76x76\"\n    },\n    {\n      \"filename\" : \"Icon_152.png\",\n      \"idiom\" : \"ipad\",\n      \"scale\" : \"2x\",\n      \"size\" : \"76x76\"\n    },\n    {\n      \"idiom\" : \"ipad\",\n      \"scale\" : \"2x\",\n      \"size\" : \"83.5x83.5\"\n    },\n    {\n      \"filename\" : \"Icon_1024.png\",\n      \"idiom\" : \"ios-marketing\",\n      \"scale\" : \"1x\",\n      \"size\" : \"1024x1024\"\n    }\n  ],\n  \"info\" : {\n    \"author\" : \"xcode\",\n    \"version\" : 1\n  }\n}"),
}
