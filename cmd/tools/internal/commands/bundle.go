package commands

// Copyright (c) 2018 Bhojpur Consulting Private Limited, India. All rights reserved.

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import (
	"errors"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path"
	"regexp"
	"strings"

	gui "github.com/bhojpur/gui/pkg/engine"
	"github.com/urfave/cli/v2"
)

const fileHeader = "// auto-generated: Bhojpur GUI - Foundation Framework\n" + // to exclude this file in goreportcard (it has to be first)
	"// Code generated by '$ guiutl bundle'. DO NOT EDIT." // idiomatic mark, see https://golang.org/s/generatedcode

// Bundle returns the vendor cli command
func Bundle() *cli.Command {
	b := &Bundler{}

	return &cli.Command{
		Name:        "bundle",
		Usage:       "Embeds static content into your Go application",
		Description: "Each resource will have a generated filename unless specified.",
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:        "name",
				Usage:       "The variable name to assign the resource (file mode only).",
				Destination: &b.name,
			},
			&cli.StringFlag{
				Name:        "output",
				Aliases:     []string{"o"},
				Usage:       "Specify an output file instead of printing to standard output.",
				Destination: &b.out,
			},
			&cli.StringFlag{
				Name:        "package",
				Aliases:     []string{"pkg"},
				Usage:       "The package to output in headers (if not appending).",
				Value:       "main",
				Destination: &b.pkg,
			},
			&cli.StringFlag{
				Name:        "prefix",
				Usage:       "A prefix for variables (ignored if name is set).",
				Value:       "resource",
				Destination: &b.prefix,
			},
			&cli.BoolFlag{
				Name:        "append",
				Aliases:     []string{"a"},
				Usage:       "Append an existing go file (don't output headers).",
				Destination: &b.noheader,
			},
		},
		Action: b.bundleAction,
	}
}

// Bundler bundles resources into Go code.
type Bundler struct {
	name, pkg, out string
	prefix         string
	noheader       bool
}

// AddFlags adds all the command line flags for passing to the Bundler.
//
// Deprecated: Access to the individual cli commands are being removed.
func (b *Bundler) AddFlags() {
	flag.StringVar(&b.name, "name", "", "The variable name to assign the resource (file mode only)")
	flag.StringVar(&b.out, "o", "", "Specify an output file instead of printing to standard output")
	flag.StringVar(&b.pkg, "package", "main", "The package to output in headers (if not appending)")
	flag.StringVar(&b.prefix, "prefix", "resource", "A prefix for variables (ignored if name is set)")
	flag.BoolVar(&b.noheader, "append", false, "Append an existing go file (don't output headers)")
}

// PrintHelp prints the help message for the bundle command.
//
// Deprecated: Access to the individual cli commands are being removed.
func (b *Bundler) PrintHelp(indent string) {
	fmt.Println(indent, "The bundle command embeds static content into your go application.")
	fmt.Println(indent, "Each resource will have a generated filename unless specified")
	fmt.Println(indent, "Command usage: guiutl bundle [parameters] file|directory")
}

// Run runs the bundle command.
//
// Deprecated: A better version will be exposed in the future.
func (b *Bundler) Run(args []string) {
	if len(args) != 1 {
		gui.LogError("Missing required file or directory parameter after flags", nil)
		return
	}

	outFile := os.Stdout
	if b.out != "" {
		fileModes := os.O_RDWR | os.O_CREATE | os.O_TRUNC
		if b.noheader {
			fileModes = os.O_RDWR | os.O_APPEND
		}

		f, err := os.OpenFile(b.out, fileModes, 0666)
		if err == nil {
			outFile = f
		} else {
			if os.IsNotExist(err) {
				f, err = os.Create(b.out)
				if err == nil {
					outFile = f
				} else {
					gui.LogError("Unable to read, or create, output file : "+b.out, err)
					return
				}
			} else {
				gui.LogError("Unable to open output file", err)
				return
			}
		}
	}

	switch stat, err := os.Stat(args[0]); {
	case os.IsNotExist(err):
		gui.LogError("Specified file could not be found", err)
	case stat.IsDir():
		b.noheader = false
		b.dirBundle(args[0], outFile)
	case b.name != "":
		b.prefix = ""
		fallthrough
	default:
		b.doBundle(args[0], outFile)
	}
}

func (b *Bundler) bundleAction(ctx *cli.Context) (err error) {
	if ctx.Args().Len() != 1 {
		return errors.New("missing required file or directory parameter after flags")
	}

	outFile := os.Stdout
	if b.out != "" {
		file, closeFile, err := openOutputFile(b.out, b.noheader)
		if err != nil {
			return err
		}
		defer func() {
			if r := closeFile(); r != nil {
				err = r
			}
		}()
		outFile = file
	}

	arg := ctx.Args().First()
	switch stat, err := os.Stat(arg); {
	case os.IsNotExist(err):
		gui.LogError("Specified file could not be found", err)
		return err
	case stat.IsDir():
		b.noheader = false
		return b.dirBundle(arg, outFile)
	case b.name != "":
		b.prefix = ""
		fallthrough
	default:
		b.doBundle(arg, outFile)
	}

	return nil
}

func (b *Bundler) dirBundle(dirpath string, out *os.File) error {
	files, err := ioutil.ReadDir(dirpath)
	if err != nil {
		gui.LogError("Error reading specified directory", err)
		return err
	}

	for i, file := range files {
		filename := file.Name()
		if path.Ext(filename) == ".go" {
			continue
		}

		b.name = ""

		b.doBundle(path.Join(dirpath, filename), out)
		if i == 0 { // only show header on first iteration
			b.noheader = true
		}
	}

	return nil
}

// Bundle takes a file (at filepath) and serialises it into Go to be output into
// a generated bundle file. The go file will be part of the specified package
// (pkg) and the data will be assigned to variable named "name". If you are
// appending an existing resource file then pass true to noheader as the headers
// should only be output once per file.
func (b *Bundler) doBundle(filepath string, out *os.File) {
	if !b.noheader {
		writeHeader(b.pkg, out)
	}

	if b.name == "" {
		b.name = sanitiseName(path.Base(filepath), b.prefix)
	}
	writeResource(filepath, b.name, out)
}

func openOutputFile(filePath string, noheader bool) (file *os.File, close func() error, err error) {
	fileModes := os.O_RDWR | os.O_CREATE | os.O_TRUNC
	if noheader {
		fileModes = os.O_RDWR | os.O_APPEND
	}

	f, err := os.OpenFile(filePath, fileModes, 0666)
	if err != nil {
		if !os.IsNotExist(err) {
			gui.LogError("Unable to open output file", err)
			return nil, nil, err
		}

		// try creating the file
		f, err = os.Create(filePath)
		if err != nil {
			gui.LogError("Unable to read, or create, output file : "+filePath, err)
			return nil, nil, err
		}
	}

	return f, f.Close, nil
}

func sanitiseName(file, prefix string) string {
	titled := strings.Title(file)

	reg, _ := regexp.Compile("[^a-zA-Z0-9]+")
	name := reg.ReplaceAllString(titled, "")

	return prefix + name
}

func writeHeader(pkg string, out *os.File) {
	fmt.Fprintln(out, fileHeader)
	fmt.Fprintln(out)
	fmt.Fprintln(out, "package", pkg)
	fmt.Fprintln(out)
	fmt.Fprintln(out, "import gui \"github.com/bhojpur/gui/pkg/engine\"")
	fmt.Fprintln(out)
}

func writeResource(file, name string, f io.Writer) {
	res, err := gui.LoadResourceFromPath(file)
	if err != nil {
		gui.LogError("Unable to load file "+file, err)
		return
	}

	staticRes, ok := res.(*gui.StaticResource)
	if !ok {
		gui.LogError("Unable to format resource", fmt.Errorf("unexpected resource type %T", res))
		return
	}

	v := fmt.Sprintf("var %s = &gui.StaticResource{\n\tStaticName: %q,\n\tStaticContent: []byte(\n\t\t%q),\n}\n", name, staticRes.StaticName, staticRes.StaticContent)
	_, err = f.Write([]byte(v))
	if err != nil {
		gui.LogError("Unable to write to bundled file", err)
	}
}
